# 版本管理原理（Git）

这份文档解释 Git 的核心概念与工作机制，帮助理解命令背后的原理。

## 一、数据模型与提交图
- Git 把内容存为不可变对象（blob、tree、commit），每个对象用哈希（SHA-1/更现代实现可替换）标识。
- `commit` 记录一次快照和指向父提交的引用，形成有向无环图（DAG）。
- 分支其实就是指向某个 `commit` 的可移动指针，如 `main` 指向最新提交。

简化示意：
```
A <-- B <-- C   (main)
^     ^
|     └-- D <-- E  (feature)
```
合并时会产生新的提交（通常两个父指针），如 `M`：
```
A <-- B <-- C ---------
           \         \
            D <-- E --- M (main)
```

## 二、三个区与一次提交流程
- 工作区（Working Directory）：你编辑文件的地方。
- 暂存区（Staging/Index）：`git add` 把变更纳入下一次提交的候选集。
- 本地仓库（Local Repo）：`git commit` 把暂存快照永久记录为一个提交。

流程：修改 → `git add` → `git commit`。随后 `git push` 把本地提交发送到远端仓库。

## 三、远端仓库与跟踪分支
- 远端（`origin` 等）是另一个仓库的引用，可在本地维护其分支快照（如 `origin/main`）。
- `git push`：把本地分支的新增提交上传到远端并更新远端分支；首次用 `-u` 建立上游关系。
- `git fetch`：仅同步远端的最新指针到本地（不改工作区）。
- `git pull`：`fetch + merge`（或 `rebase`），把远端更新融入当前分支。

## 四、合并（merge）与变基（rebase）
- 合并：保留分支分叉历史，创建一个新合并提交，历史更真实但可能“枝杈”较多。
- 变基：把你的提交“平移”到目标分支之上，历史更线性、易读，但变更了提交哈希（不建议对已共享的公开分支做强制变基）。
- `git pull --rebase` 常用于保持本地历史整洁。

## 五、快进（Fast-forward）与非快进
- 若目标分支指针落后而没有分叉，合并会直接把指针“快进”（不产生新提交）。
- 若存在分叉需要整合，合并会生成一个新合并提交（非快进）。

## 六、冲突与解决
- 当 Git 无法自动整合两边变更时产生冲突，文件内出现冲突标记。
- 解决步骤：编辑文件保留正确内容 → `git add` → `git commit` 完成合并 → 如需继续推送则 `git push`。

## 七、裸仓库与远端
- 裸仓库（`git init --bare`）没有工作区，专供作为共享远端使用；本地仓库可以 `push` 到它并从它 `clone/pull`。
- 托管平台（GitHub、Gitee）本质上也是远端仓库，提供权限与协作功能。

## 八、标签（tag）与版本发布
- 标签是指向某个提交的不可移动引用，常用于标记版本点，如 `v1.0.0`。
- 创建与推送：`git tag v1.0.0`，`git push origin v1.0.0`。

## 九、典型工作流建议
- 在 `main` 保持稳定；功能开发用主题分支（`feature/*`）。
- 提交尽量小而清晰，信息完整；先 `fetch` 再合并/变基，减少冲突。
- 远端协作用 Pull Request/Merge Request；合入前跑测试与代码审查。
- 对公共分支避免强制 push（`--force`）；必要时用 `--force-with-lease` 更安全。

## 十、排错与可视化
- `git status`、`git log --oneline --graph --decorate` 快速洞察当前状态与分支结构。
- 用 `.gitignore` 排除临时文件与构建产物，保持仓库整洁。

这份原理说明与配套的《命令行操作教程》相互呼应：先理解三步（add/commit/push），再在真实协作场景选择合并或变基策略。